---
title: "p8105_hw1_zdz2101"
author: "Zelos Zhu"
date: "9/18/2018"
output: github_document
---

#Problem 1
```{r Load libs, message=FALSE}
library(tidyverse)
```

```{r Problem 1a}
problem1_df <- tibble(numeric_vec = runif(n = 10, min = 0, max = 5),
                      logical_vec = numeric_vec > 2,
                      char_vec = c("My", "name", "is", "Zelos", "Zhu", "and", "I", "like", "to", "eat"),
                      factor_vec = factor(  c( rep( c("small", "medium", "large"), 3), "x-large")  )
                      )
print(problem1_df)
#means <- apply(problem1_df, 2, mean) --- doesn't work
#Above line coerces all into NA, probably because there is non-numeric in it, good to know

means_prob1 <- c(mean(problem1_df$numeric_vec),
                 mean(problem1_df$logical_vec),
                 mean(problem1_df$char_vec),
                 mean(problem1_df$factor_vec))
means_prob1
```

The mean() function successfully worked for the numeric and logical vectors of the data frame while it produced NAs for the character and factor vectors. This makes sense: the mean of the first vector could be calculated since it is a numeric variable. It's exactly what we think it should be: the sum of the elements divided by the number of elements. As a result the mean is `r round(means_prob1[1], 2)`. 

Interestingly enough, the second vector in the data frame could also have a mean and that is because R seems to automatically consider FALSE into 0 and TRUE into 1. So, taking a "mean" of a logical allows us to see the proportion of TRUE cases, similarly if we were to take the sum we would see the total counts of TRUE's. As expected, a mean could not be taken from neither the character or factor varaibles and that is because character and factor variables cannot be used with traditional "mathematical" functions. 

```{r Problem 1b}
mean_converted_char <- mean(as.numeric(as.factor(problem1_df$char_vec)))
mean_converted_char

mean_converted_factor <- mean(as.numeric(problem1_df$factor_vec))
mean_converted_factor
```

Once you convert character into factor and then numeric, you can use traditional math functions, but it has practically no meaning. So in the case of my character vector, I had 10 unique "character" values, which turned into 10 different levels of factors, and as a result when you convert the factor into numeric it turned into a jumbled mess of numbers: `r as.numeric(as.factor(problem1_df$char_vec))`. The mean of that is `r mean_converted_char` but this does not particularly have much interpretability compared to the 10 word sentence I wrote. 

The same concept applies for my 4th factor vector, there are only 4 unique values, so it has 4 levels, so when coerced numerically it came out to `r c(rep(c(1:3),3), 4)` and mean of that is `r mean_converted_factor`. Again this does not quite have any sort of meaning compared to a vector of "sizes" which I initially created.


#Problem 2
```{r Prob2 make plotting df}
problem2_df <- tibble( x = rnorm(1000),
                       y = rnorm(1000),
                       is_sum_positive = (x + y) > 0,
                       num_coerce = as.numeric(is_sum_positive),
                       factor_coerce = as.factor(is_sum_positive))
print(head(problem2_df))
```

The size of the dataset is `r nrow(problem2_df)` rows and `r ncol(problem2_df)` columns.
The mean of x is `r round( mean(problem2_df$x), 2)`.
The median of x is `r round( median(problem2_df$x), 2)`.
The proportion of cases for which the logical vector is TRUE is `r round( mean(problem2_df$is_sum_positive), 2)`. 

```{r Prob2 graphs}
hw1plot_1 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = is_sum_positive))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

hw1plot_2 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = num_coerce))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

hw1plot_3 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = factor_coerce))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

library(gridExtra)
grid.arrange(hw1plot_1, hw1plot_2, hw1plot_3, nrow=1)
```

The color arrangement seems to be the exact same for the logical and factor variables, it separates each TRUE/FALSE into a discrete value and assigns it a particular color (in this case a light red and cyan). My guess on why this is, is that similar to how mathematical functions automaticcaly register logicals as 0/1's , in this setting it automatically changes it to factors of 2 levels: TRUE/FALSE. 