p8105\_hw1\_zdz2101
================
Zelos Zhu
9/18/2018

Problem 1
=========

``` r
library(tidyverse)
```

``` r
problem1_df <- tibble(numeric_vec = runif(n = 10, min = 0, max = 5),
                      logical_vec = numeric_vec > 2,
                      char_vec = c("My", "name", "is", "Zelos", "Zhu", "and", "I", "like", "to", "eat"),
                      factor_vec = factor(  c( rep( c("small", "medium", "large"), 3), "x-large")  )
                      )
print(problem1_df)
```

    ## # A tibble: 10 x 4
    ##    numeric_vec logical_vec char_vec factor_vec
    ##          <dbl> <lgl>       <chr>    <fct>     
    ##  1        1.67 FALSE       My       small     
    ##  2        3.94 TRUE        name     medium    
    ##  3        3.87 TRUE        is       large     
    ##  4        4.42 TRUE        Zelos    small     
    ##  5        4.17 TRUE        Zhu      medium    
    ##  6        3.14 TRUE        and      large     
    ##  7        3.34 TRUE        I        small     
    ##  8        2.54 TRUE        like     medium    
    ##  9        4.96 TRUE        to       large     
    ## 10        1.89 FALSE       eat      x-large

``` r
#means <- apply(problem1_df, 2, mean) --- doesn't work
#Above line coerces all into NA, probably because there is non-numeric in it, good to know

means_prob1 <- c(mean(problem1_df$numeric_vec),
                 mean(problem1_df$logical_vec),
                 mean(problem1_df$char_vec),
                 mean(problem1_df$factor_vec))
```

    ## Warning in mean.default(problem1_df$char_vec): argument is not numeric or
    ## logical: returning NA

    ## Warning in mean.default(problem1_df$factor_vec): argument is not numeric or
    ## logical: returning NA

``` r
means_prob1
```

    ## [1] 3.393229 0.800000       NA       NA

The mean() function successfully worked for the numeric and logical vectors of the data frame while it produced NAs for the character and factor vectors. This makes sense: the mean of the first vector could be calculated since it is a numeric variable. It's exactly what we think it should be: the sum of the elements divided by the number of elements. As a result the mean is 3.39.

Interestingly enough, the second vector in the data frame could also have a mean and that is because R seems to automatically consider FALSE into 0 and TRUE into 1. So, taking a "mean" of a logical allows us to see the proportion of TRUE cases, similarly if we were to take the sum we would see the total counts of TRUE's. As expected, a mean could not be taken from neither the character or factor varaibles and that is because character and factor variables cannot be used with traditional "mathematical" functions.

``` r
mean_converted_char <- mean(as.numeric(as.factor(problem1_df$char_vec)))
mean_converted_char
```

    ## [1] 5.5

``` r
mean_converted_factor <- mean(as.numeric(problem1_df$factor_vec))
mean_converted_factor
```

    ## [1] 2.2

Once you convert character into factor and then numeric, you can use traditional math functions, but it has practically no meaning. So in the case of my character vector, I had 10 unique "character" values, which turned into 10 different levels of factors, and as a result when you convert the factor into numeric it turned into a jumbled mess of numbers: 6, 7, 4, 9, 10, 1, 3, 5, 8, 2. The mean of that is 5.5 but this does not particularly have much interpretability compared to the 10 word sentence I wrote.

The same concept applies for my 4th factor vector, there are only 4 unique values, so it has 4 levels, so when coerced numerically it came out to 1, 2, 3, 1, 2, 3, 1, 2, 3, 4 and mean of that is 2.2. Again this does not quite have any sort of meaning compared to a vector of "sizes" which I initially created.

Problem 2
=========

``` r
problem2_df <- tibble( x = rnorm(1000),
                       y = rnorm(1000),
                       is_sum_positive = (x + y) > 0,
                       num_coerce = as.numeric(is_sum_positive),
                       factor_coerce = as.factor(is_sum_positive))
print(head(problem2_df))
```

    ## # A tibble: 6 x 5
    ##        x       y is_sum_positive num_coerce factor_coerce
    ##    <dbl>   <dbl> <lgl>                <dbl> <fct>        
    ## 1 -1.38  -0.798  FALSE                    0 FALSE        
    ## 2  2.38   0.199  TRUE                     1 TRUE         
    ## 3  0.130  0.749  TRUE                     1 TRUE         
    ## 4  0.163  0.0996 TRUE                     1 TRUE         
    ## 5 -0.493 -1.08   FALSE                    0 FALSE        
    ## 6 -0.600  0.998  TRUE                     1 TRUE

The size of the dataset is 1000 rows and 5 columns. The mean of x is 0.02. The median of x is 0.09. The proportion of cases for which the logical vector is TRUE is 0.5.

``` r
hw1plot_1 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = is_sum_positive))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

hw1plot_2 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = num_coerce))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

hw1plot_3 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = factor_coerce))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

hw1plot_1
```

![](p8105_hw1_zdz2101_files/figure-markdown_github/Prob2%20graphs-1.png)

``` r
hw1plot_2
```

![](p8105_hw1_zdz2101_files/figure-markdown_github/Prob2%20graphs-2.png)

``` r
hw1plot_3
```

![](p8105_hw1_zdz2101_files/figure-markdown_github/Prob2%20graphs-3.png)

``` r
#library(gridExtra) --- for my viewing pleasure when I was working on this so I don't have to scroll through in viewer
#grid.arrange(hw1plot_1, hw1plot_2, hw1plot_3, nrow=1)
```

The color arrangement seems to be the exact same for the logical and factor variables, each point has a distinct color allocated based on the discrete values TRUE and FALSE (in this case a light red and cyan).

MY hypothesis/guess on why this is, is that similar to how R automatically register logicals as 0/1's for mathematical functions, that in this setting, ggplot2 is written such that when logicals enter an aes, it automatically considers it a factor of 2 levels: TRUE/FALSE which have correspoding numbers to them, in this case 1 and 2. This would then allow R to have an index to pull certain "colors" from some sort of color vector. Otherwise with FALSE being 0, it would be difficult to use that as an index since R objects start indexing at 1. (Just my guess)

In regards to the second plot where we have the blue and black dots, it seems in this case our color is based on some sort of gradient, the range of which is defined as 0 to 1. In our case we only have exactly 0's and 1's because we coerced it from logical to numeric. As a result we have a concentration from each of the extremes of the gradient. Say if we plugged in x as our color we would see this entire black(low)-blue(high) gradient generated going left to right. The same could be said for if we plugged in y instead, but we would generate that gradient from bottom to top.
