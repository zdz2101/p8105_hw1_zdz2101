p8105\_hw1\_zdz2101
================
Zelos Zhu
9/18/2018

Problem 1
=========

``` r
library(tidyverse)
```

``` r
problem1_df <- tibble(numeric_vec = runif(n = 10, min = 0, max = 5),
                      logical_vec = numeric_vec > 2,
                      char_vec = c("My", "name", "is", "Zelos", "Zhu", "and", "I", "like", "to", "eat"),
                      factor_vec = factor(  c( rep( c("small", "medium", "large"), 3), "x-large")  )
                      )
print(problem1_df)
```

    ## # A tibble: 10 x 4
    ##    numeric_vec logical_vec char_vec factor_vec
    ##          <dbl> <lgl>       <chr>    <fct>     
    ##  1       1.85  FALSE       My       small     
    ##  2       0.814 FALSE       name     medium    
    ##  3       4.21  TRUE        is       large     
    ##  4       1.42  FALSE       Zelos    small     
    ##  5       2.88  TRUE        Zhu      medium    
    ##  6       3.67  TRUE        and      large     
    ##  7       0.833 FALSE       I        small     
    ##  8       0.278 FALSE       like     medium    
    ##  9       4.07  TRUE        to       large     
    ## 10       1.19  FALSE       eat      x-large

``` r
#means <- apply(problem1_df, 2, mean) --- doesn't work
#Above line coerces all into NA, probably because there is non-numeric in it, good to know

means_prob1 <- c(mean(problem1_df$numeric_vec),
                 mean(problem1_df$logical_vec),
                 mean(problem1_df$char_vec),
                 mean(problem1_df$factor_vec))
```

    ## Warning in mean.default(problem1_df$char_vec): argument is not numeric or
    ## logical: returning NA

    ## Warning in mean.default(problem1_df$factor_vec): argument is not numeric or
    ## logical: returning NA

``` r
means_prob1
```

    ## [1] 2.122697 0.400000       NA       NA

The mean() function successfully worked for the numeric and logical vectors of the data frame while it produced NAs for the character and factor vectors. This makes sense: the mean of the first vector could be calculated since it is a numeric variable. It's exactly what we think it should be: the sum of the elements divided by the number of elements. As a result the mean is 2.12.

Interestingly enough, the second vector in the data frame could also have a mean and that is because R seems to automatically consider FALSE into 0 and TRUE into 1. So, taking a "mean" of a logical allows us to see the proportion of TRUE cases, similarly if we were to take the sum we would see the total counts of TRUE's. As expected, a mean could not be taken from neither the character or factor varaibles and that is because character and factor variables cannot be used with traditional "mathematical" functions.

``` r
mean_converted_char <- mean(as.numeric(as.factor(problem1_df$char_vec)))
mean_converted_char
```

    ## [1] 5.5

``` r
mean_converted_factor <- mean(as.numeric(problem1_df$factor_vec))
mean_converted_factor
```

    ## [1] 2.2

Once you convert character into factor and then numeric, you can use traditional math functions, but it has practically no meaning. So in the case of my character vector, I had 10 unique "character" values, which turned into 10 different levels of factors, and as a result when you convert the factor into numeric it turned into a jumbled mess of numbers: 6, 7, 4, 9, 10, 1, 3, 5, 8, 2. The mean of that is 5.5 but this does not particularly have much interpretability compared to the 10 word sentence I wrote.

The same concept applies for my 4th factor vector, there are only 4 unique values, so it has 4 levels, so when coerced numerically it came out to 1, 2, 3, 1, 2, 3, 1, 2, 3, 4 and mean of that is 2.2. Again this does not quite have any sort of meaning compared to a vector of "sizes" which I initially created.

Problem 2
=========

``` r
problem2_df <- tibble( x = rnorm(1000),
                       y = rnorm(1000),
                       is_sum_positive = (x + y) > 0,
                       num_coerce = as.numeric(is_sum_positive),
                       factor_coerce = as.factor(is_sum_positive))
print(head(problem2_df))
```

    ## # A tibble: 6 x 5
    ##           x       y is_sum_positive num_coerce factor_coerce
    ##       <dbl>   <dbl> <lgl>                <dbl> <fct>        
    ## 1  0.421     0.288  TRUE                     1 TRUE         
    ## 2  0.550     0.117  TRUE                     1 TRUE         
    ## 3  0.000980 -1.63   FALSE                    0 FALSE        
    ## 4 -0.239     0.0784 FALSE                    0 FALSE        
    ## 5  0.336    -1.08   FALSE                    0 FALSE        
    ## 6  0.899     0.204  TRUE                     1 TRUE

The size of the dataset is 1000 rows and 5 columns. The mean of x is 0.01. The median of x is 0.01. The proportion of cases for which the logical vector is TRUE is 0.51.

``` r
hw1plot_1 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = is_sum_positive))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

hw1plot_2 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = num_coerce))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

hw1plot_3 <- (ggplot(problem2_df, aes(x=x, y=y))
            + geom_point( aes(color = factor_coerce))
            + ggtitle("Scatterplot of 1000 points based on normal distribution")
            + geom_abline(intercept = 0, slope = -1)
            + theme(plot.title = element_text(size = 10, face = "bold")))

library(gridExtra)
```

    ## 
    ## Attaching package: 'gridExtra'

    ## The following object is masked from 'package:dplyr':
    ## 
    ##     combine

``` r
grid.arrange(hw1plot_1, hw1plot_2, hw1plot_3, nrow=1)
```

![](p8105_hw1_zdz2101_files/figure-markdown_github/Prob2%20graphs-1.png)

The color arrangement seems to be the exact same for the logical and factor variables, it separates each TRUE/FALSE into a discrete value and assigns it a particular color (in this case a light red and cyan). My guess on why this is, is that similar to how mathematical functions automaticcaly register logicals as 0/1's , in this setting it automatically changes it to factors of 2 levels: TRUE/FALSE.
